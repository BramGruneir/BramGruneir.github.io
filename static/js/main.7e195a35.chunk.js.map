{"version":3,"sources":["App.tsx","serviceWorker.js","index.js"],"names":["generateKey","props","Math","random","toString","pickBoxClass","node","failed","replicas","FailureMode","Node","boxClassName","this","replicaClassName","className","id","React","Component","AvailabilityZone","nodes","map","n","DataCenter","azs","availabilityZones","az","Region","dcs","datacenters","dc","limit","num","min","max","MainForm","state","numberRegions","DCsPerRegion","AZsPerDC","NodesPerAZ","replicationFactor","failureMode","failedRegions","failedDCs","failedAZs","failedNodes","deadReplicas","allowableDead","regions","handleNumberRegionsChange","bind","handleDCsPerRegionChange","handleAZsPerDCChange","handleNodesPerAZChange","handleReplicationFactorChange","handleFailureModeChange","curState","getCurrentState","setState","update","event","value","parseInt","target","forceUpdate","None","floor","r","regionProps","key","d","dataCenterProps","a","availabilityZoneProps","nodeProps","push","i","region","forEach","j","k","l","nodeCount","type","onChange","name","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7e195a35.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\ninterface NodeProps {\n  key: string;\n  id: number;\n  failed: boolean;\n  replicas: number;\n}\n\nfunction generateKey(props: NodeProps): string {\n  //return `${props.id}-${props.replicas}-${props.failed}`;\n  return Math.random().toString();\n}\n\nfunction pickBoxClass(node: NodeProps): string {\n  if (node.failed) {\n    return \"Box-failed\"\n  }\n  if (node.replicas === 0) {\n    return \"Box-empty\"\n  }\n  return \"Box\"\n}\n\nclass Node extends React.Component<NodeProps, {}> {\n  render() {\n    let boxClassName = pickBoxClass(this.props);\n    let replicaClassName = this.props.replicas > 0 ? \"Replicas-full\" : \"Replicas-empty\";\n    return (\n      <div className={`${boxClassName}`}>\n        <div>Node {this.props.id}</div>\n        <div className={`${replicaClassName}`}>Replicas {this.props.replicas}</div>\n      </div>\n    );\n  }\n}\n\ninterface AvailabilityZoneProps extends NodeProps {\n  nodes: Array<NodeProps>;\n}\n\nclass AvailabilityZone extends React.Component<AvailabilityZoneProps, {}> {\n  render() {\n    let nodes = this.props.nodes.map((n) =>\n      <Node {...n} />\n    );\n    let boxClassName = pickBoxClass(this.props);\n    let replicaClassName = this.props.replicas > 0 ? \"Replicas-full\" : \"Replicas-empty\";\n    return (\n      <div className={`${boxClassName}`}>\n        <div>AZ {this.props.id}</div>\n        <div className={`${replicaClassName}`}>Replicas {this.props.replicas}</div>\n        {nodes}\n      </div>\n    );\n  }\n}\n\ninterface DataCenterProps extends NodeProps {\n  availabilityZones: Array<AvailabilityZoneProps>;\n}\n\nclass DataCenter extends React.Component<DataCenterProps, {}> {\n  render() {\n    let azs = this.props.availabilityZones.map((az) =>\n      <AvailabilityZone {...az} />\n    );\n    let boxClassName = pickBoxClass(this.props);\n    let replicaClassName = this.props.replicas > 0 ? \"Replicas-full\" : \"Replicas-empty\";\n    return (\n      <div className={`${boxClassName}`}>\n        <div>DC {this.props.id}</div>\n        <div className={`${replicaClassName}`}>Replicas {this.props.replicas}</div>\n        {azs}\n      </div>\n    );\n  }\n}\n\ninterface RegionProps extends NodeProps {\n  datacenters: Array<DataCenterProps>;\n}\n\nclass Region extends React.Component<RegionProps, {}> {\n  render() {\n    let dcs = this.props.datacenters.map((dc) =>\n      <DataCenter {...dc} />\n    );\n    let boxClassName = pickBoxClass(this.props);\n    let replicaClassName = this.props.replicas > 0 ? \"Replicas-full\" : \"Replicas-empty\";\n    return (\n      <div className={`${boxClassName}`}>\n        <div>Region {this.props.id}</div>\n        <div className={`${replicaClassName}`}>Replicas {this.props.replicas}</div>\n        <div className=\"App-container\">\n          {dcs}\n        </div>\n      </div>\n    );\n  }\n}\n\nenum FailureMode {\n  None,\n  Region,\n  DataCenter,\n  AvailabilityZone,\n  Node,\n}\n\ninterface MainFormState {\n  numberRegions: number;\n  DCsPerRegion: number;\n  AZsPerDC: number;\n  NodesPerAZ: number;\n  replicationFactor: number;\n  failureMode: FailureMode;\n  failedRegions: number;\n  failedDCs: number;\n  failedAZs: number;\n  failedNodes: number;\n  deadReplicas: number;\n  allowableDead: number;\n  regions: Array<RegionProps>;\n}\n\nfunction limit(num: number, min: number, max: number): number {\n  if (num < min) {\n    return min;\n  }\n  if (num > max) {\n    return max;\n  }\n  return num;\n}\n\nclass MainForm extends React.Component<{}, MainFormState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      numberRegions: 3,\n      DCsPerRegion: 3,\n      AZsPerDC: 3,\n      NodesPerAZ: 3,\n      replicationFactor: 3,\n      failureMode: FailureMode.Region,\n      failedRegions: 0,\n      failedDCs: 0,\n      failedAZs: 0,\n      failedNodes: 0,\n      deadReplicas: 0,\n      allowableDead: 0,\n      regions: [],\n    };\n\n    this.handleNumberRegionsChange = this.handleNumberRegionsChange.bind(this);\n    this.handleDCsPerRegionChange = this.handleDCsPerRegionChange.bind(this);\n    this.handleAZsPerDCChange = this.handleAZsPerDCChange.bind(this);\n    this.handleNodesPerAZChange = this.handleNodesPerAZChange.bind(this);\n    this.handleReplicationFactorChange = this.handleReplicationFactorChange.bind(this);\n    this.handleFailureModeChange = this.handleFailureModeChange.bind(this);\n  }\n\n  componentDidMount() {\n    let curState = this.getCurrentState();\n    this.setState(this.update(curState))\n  }\n\n  getCurrentState(): MainFormState {\n    return {\n      numberRegions: this.state.numberRegions,\n      DCsPerRegion: this.state.DCsPerRegion,\n      AZsPerDC: this.state.AZsPerDC,\n      NodesPerAZ: this.state.NodesPerAZ,\n      replicationFactor: this.state.replicationFactor,\n      failureMode: this.state.failureMode,\n      failedRegions: this.state.failedRegions,\n      failedDCs: this.state.failedDCs,\n      failedAZs: this.state.failedAZs,\n      failedNodes: this.state.failedNodes,\n      deadReplicas: this.state.deadReplicas,\n      allowableDead: this.state.allowableDead,\n      regions: [],\n    };\n  }\n\n  handleNumberRegionsChange(event: any) {\n    let value = parseInt(event.target.value) || 1;\n    value = limit(value, 1, 10);\n    let curState = this.getCurrentState();\n    curState.numberRegions = value;\n    this.setState(this.update(curState))\n  }\n  handleDCsPerRegionChange(event: any) {\n    let value = parseInt(event.target.value) || 1;\n    value = limit(value, 1, 10);\n    let curState = this.getCurrentState();\n    curState.DCsPerRegion = value;\n    this.setState(this.update(curState))\n  }\n  handleAZsPerDCChange(event: any) {\n    let value = parseInt(event.target.value) || 1;\n    value = limit(value, 1, 10);\n    let curState = this.getCurrentState();\n    curState.AZsPerDC = value;\n    this.setState(this.update(curState))\n  }\n  handleNodesPerAZChange(event: any) {\n    let value = parseInt(event.target.value) || 1;\n    value = limit(value, 1, 100);\n    let curState = this.getCurrentState();\n    curState.NodesPerAZ = value;\n    this.setState(this.update(curState))\n  }\n  handleReplicationFactorChange(event: any) {\n    let value = parseInt(event.target.value) || 1;\n    if (value % 2 === 0) {\n      if (this.state.replicationFactor > value) {\n        value--;\n      } else {\n        value++;\n      }\n    }\n    value = limit(value, 1, 99);\n    let curState = this.getCurrentState();\n    curState.replicationFactor = value;\n    this.setState(this.update(curState), this.forceUpdate)\n  }\n  handleFailureModeChange(event: any) {\n    let curState = this.getCurrentState();\n    curState.failureMode = parseInt(event.target.value) || FailureMode.None;\n    this.setState(this.update(curState))\n  }\n\n  update(state: MainFormState): MainFormState {\n    // Spec out the whole system.\n    state.allowableDead = Math.floor(state.replicationFactor / 2);\n\n    // Regions\n    state.regions = [];\n    for (let r = 0; r < state.numberRegions; r++) {\n      let regionProps: RegionProps = {\n        key: \"\",\n        id: r + 1,\n        failed: false,\n        datacenters: [],\n        replicas: 0,\n      }\n\n      // Data Centers\n      for (let d = 0; d < state.DCsPerRegion; d++) {\n        let dataCenterProps: DataCenterProps = {\n          key: \"\",\n          id: d + 1,\n          failed: false,\n          replicas: 0,\n          availabilityZones: [],\n        }\n\n        // Availability Zones\n        for (let a = 0; a < state.AZsPerDC; a++) {\n          let availabilityZoneProps: AvailabilityZoneProps = {\n            key: \"\",\n            id: a + 1,\n            failed: false,\n            replicas: 0,\n            nodes: [],\n          }\n\n          // Nodes\n          for (let a = 0; a < state.NodesPerAZ; a++) {\n            let nodeProps: NodeProps = {\n              key: \"\",\n              id: a + 1,\n              failed: false,\n              replicas: 0,\n            }\n            availabilityZoneProps.nodes.push(nodeProps);\n          }\n          dataCenterProps.availabilityZones.push(availabilityZoneProps);\n        }\n        regionProps.datacenters.push(dataCenterProps);\n      }\n      state.regions.push(regionProps);\n    }\n\n    // Add the example range.  This is not fun, there must be a better way.\n    // Replicas per region\n    for (let i = 0; i < state.replicationFactor; i++) {\n      let region = i % state.numberRegions;\n      state.regions[region].replicas++;\n    }\n    // Replicas per DC\n    state.regions.forEach(r => {\n      for (let i = 0; i < r.replicas; i++) {\n        let dc = i % state.DCsPerRegion;\n        r.datacenters[dc].replicas++;\n      }\n    });\n    // Replicas per AZ\n    state.regions.forEach(r =>\n      r.datacenters.forEach(dc => {\n        for (let i = 0; i < dc.replicas; i++) {\n          let az = i % state.AZsPerDC;\n          dc.availabilityZones[az].replicas++;\n        }\n      })\n    );\n    // Replicas per Nodes\n    state.regions.forEach(r =>\n      r.datacenters.forEach(dc =>\n        dc.availabilityZones.forEach(az => {\n          // This is technically not needed, can't put more than one replica on a node.\n          for (let i = 0; i < az.replicas; i++) {\n            let n = i % state.NodesPerAZ;\n            az.nodes[n].replicas++;\n          }\n        })\n      )\n    );\n\n    // Check for failures.\n    state.deadReplicas = 0;\n    state.failedRegions = 0;\n    state.failedDCs = 0;\n    state.failedAZs = 0;\n    state.failedNodes = 0;\n\n    // Regions\n    if (state.failureMode === FailureMode.Region) {\n      for (let i = 0; i < state.numberRegions; i++) {\n        if (state.regions[i].replicas === 0) {\n          // An empty region means that the range never wrapped and we know the\n          // rest of Regions or DCs will be empty.\n          break;\n        }\n        if (state.deadReplicas + state.regions[i].replicas <= state.allowableDead) {\n          state.regions[i].failed = true;\n          state.deadReplicas += state.regions[i].replicas;\n          state.failedRegions++;\n        } else {\n          // Don't continue here as these are traversed in order. This ensures\n          // we don't kill a region with less replicas. We want worst case\n          // scenario every time.\n          break;\n        }\n      }\n    }\n\n    // DCs\n    if (state.failureMode > FailureMode.None &&\n      state.failureMode <= FailureMode.DataCenter &&\n      state.deadReplicas < state.allowableDead) {\n      // Traverse the first DC in each region, then the second DC in each region ...\n      let i = -1;\n      let j = 0;\n      while (state.deadReplicas < state.allowableDead) {\n        i++;\n        if (i >= state.numberRegions) {\n          i = 0;\n          j++;\n          if (j >= state.DCsPerRegion) {\n            // We are at the end.\n            break;\n          }\n        }\n        if (state.regions[i].failed) {\n          // Skip all failed regions.\n          continue\n        }\n        if ((state.regions[i].replicas === 0) ||\n          (state.regions[i].datacenters[j].replicas === 0)) {\n          // An empty region or datacenter means that the range never wrapped\n          // and we know the rest of Regions or DCs will be empty.\n          break;\n        }\n        if (state.deadReplicas + state.regions[i].datacenters[j].replicas <= state.allowableDead) {\n          state.regions[i].datacenters[j].failed = true;\n          state.deadReplicas += state.regions[i].datacenters[j].replicas;\n          state.failedDCs++;\n        } else {\n          // Don't continue here as these are traversed in order. This ensures\n          // we don't kill a DC with less replicas. We want worst case scenario\n          // every time.\n          break;\n        }\n      }\n    }\n\n    // AZs\n    if (state.failureMode > FailureMode.None &&\n      state.failureMode <= FailureMode.AvailabilityZone &&\n      state.deadReplicas < state.allowableDead) {\n      // Traversal order for a 3x3x3: (Region-DC-AZ)\n      // 1-1-1, 2-1-1, 3-1-1,\n      // 1-2-1, 2-2-1, 3-2-1,\n      // 1-3-1, 2-3-1, 3-3-1,\n      // 1-1-2, 2-1-2, 3-1-2,\n      // 1-2-2, 2-2-2, 3-2-2,\n      // 1-3-2, 2-3-2, 3-3-2,\n      // 1-1-3, 2-1-3, 3-1-3,\n      // 1-2-3, 2-2-3, 3-2-3,\n      // 1-3-3, 2-3-3, 3-3-3,\n      let i = -1;\n      let j = 0;\n      let k = 0;\n      while (state.deadReplicas < state.allowableDead) {\n        i++;\n        if (i >= state.numberRegions) {\n          i = 0;\n          j++;\n          if (j >= state.DCsPerRegion) {\n            j = 0;\n            k++;\n            if (k >= state.AZsPerDC) {\n              // We are at the end.\n              break;\n            }\n          }\n        }\n        if (state.regions[i].failed ||\n          state.regions[i].datacenters[j].failed) {\n          // Skip all failed regions and datacenters.\n          continue;\n        }\n        if ((state.regions[i].replicas === 0) ||\n          (state.regions[i].datacenters[j].replicas === 0) ||\n          (state.regions[i].datacenters[j].availabilityZones[k].replicas === 0)) {\n          // An empty region, DC or AZ means that the range never wrapped\n          // and we know the rest of Regions, DCs or AZs will be empty.\n          break;\n        }\n\n        if (state.deadReplicas + state.regions[i].datacenters[j].availabilityZones[k].replicas <= state.allowableDead) {\n          state.regions[i].datacenters[j].availabilityZones[k].failed = true;\n          state.deadReplicas += state.regions[i].datacenters[j].availabilityZones[k].replicas;\n          state.failedAZs++;\n        } else {\n          // Don't continue here as these are traversed in order. This ensures\n          // we don't kill a AZ with less replicas. We want worst case scenario\n          // every time.\n          break;\n        }\n      }\n    }\n\n    // Nodes\n    if (state.failureMode > FailureMode.None &&\n      state.failureMode <= FailureMode.Node &&\n      state.deadReplicas < state.allowableDead) {\n      // Traversal order for a 2x2x2x2: (Region-DC-AZ-Nodes)\n      // 1-1-1-1, 2-1-1-1,\n      // 1-2-1-1, 2-2-1-1,\n      // 1-1-2-1, 2-1-2-1,\n      // 1-2-2-1, 2-2-2-1,\n      // 1-1-1-2, 2-1-1-2,\n      // 1-2-1-2, 2-2-1-2,\n      // 1-1-2-2, 2-1-2-2,\n      // 1-2-2-2, 2-2-2-2,\n\n      let i = -1;\n      let j = 0;\n      let k = 0;\n      let l = 0;\n      while (state.deadReplicas < state.allowableDead) {\n        i++;\n        if (i >= state.numberRegions) {\n          i = 0;\n          j++;\n          if (j >= state.DCsPerRegion) {\n            j = 0;\n            k++;\n            if (k >= state.AZsPerDC) {\n              k = 0;\n              l++;\n              if (l >= state.NodesPerAZ) {\n                // We are at the end.\n                break;\n              }\n            }\n          }\n        }\n        if (state.regions[i].failed ||\n          state.regions[i].datacenters[j].failed ||\n          state.regions[i].datacenters[j].availabilityZones[k].failed\n        ) {\n          // Skip all failed regions, DCs and AZs.\n          continue;\n        }\n        if ((state.regions[i].replicas === 0) ||\n          (state.regions[i].datacenters[j].replicas === 0) ||\n          (state.regions[i].datacenters[j].availabilityZones[k].replicas === 0) ||\n          (state.regions[i].datacenters[j].availabilityZones[k].nodes[l].replicas === 0)) {\n          // An empty region, DC, AZ or node means that the range never wrapped\n          // and we know the rest of Regions, DCs, AZs or nodes will be empty.\n          break;\n        }\n\n        if (state.deadReplicas + state.regions[i].datacenters[j].availabilityZones[k].nodes[l].replicas <= state.allowableDead) {\n          state.regions[i].datacenters[j].availabilityZones[k].nodes[l].failed = true;\n          state.deadReplicas += state.regions[i].datacenters[j].availabilityZones[k].nodes[l].replicas;\n          state.failedNodes++;\n        } else {\n          // Don't continue here as these are traversed in order. This ensures\n          // we don't kill a node with less replicas. We want worst case\n          // scenario every time.\n          // Since nodes should only ever have one replica, this only matters\n          // when the cluster underreplicated.\n          break;\n        }\n      }\n    }\n\n    // Add all the keys.\n    state.regions.forEach(r => {\n      r.key = generateKey(r);\n      r.datacenters.forEach(dc => {\n        dc.key = generateKey(dc);\n        dc.availabilityZones.forEach(az => {\n          az.key = generateKey(az);\n          az.nodes.forEach(n => {\n            n.key = generateKey(n);\n          });\n        });\n      });\n    });\n\n    return state;\n  }\n\n  render() {\n    let regions = this.state.regions.map((r) =>\n      <Region {...r} />\n    );\n    let nodeCount = this.state.numberRegions * this.state.DCsPerRegion * this.state.AZsPerDC * this.state.NodesPerAZ;\n    return (\n      <div>\n        <div className=\"App-form\">\n          <form>\n            <table className=\"App-table\">\n              <thead>\n                <tr>\n                  <th>Regions</th>\n                  <th>DCs per Region</th>\n                  <th>AZs per DC</th>\n                  <th>Nodes per AZ</th>\n                  <th>Replication Factor</th>\n                </tr>\n              </thead>\n              <tbody>\n                <tr>\n                  <td>\n                    <input className=\"App-input\" type=\"number\" value={this.state.numberRegions} onChange={this.handleNumberRegionsChange} />\n                  </td>\n                  <td>\n                    <input className=\"App-input\" name=\"DCsPerRegion\" type=\"number\" value={this.state.DCsPerRegion} onChange={this.handleDCsPerRegionChange} />\n                  </td>\n                  <td>\n                    <input className=\"App-input\" name=\"AZsPerDC\" type=\"number\" value={this.state.AZsPerDC} onChange={this.handleAZsPerDCChange} />\n                  </td>\n                  <td>\n                    <input className=\"App-input\" name=\"NodesPerAZ\" type=\"number\" value={this.state.NodesPerAZ} onChange={this.handleNodesPerAZChange} />\n                  </td>\n                  <td>\n                    <input className=\"App-input\" name=\"replicationFactor\" type=\"number\" value={this.state.replicationFactor} onChange={this.handleReplicationFactorChange} />\n                  </td>\n                </tr>\n              </tbody>\n            </table>\n            <div className=\"FailureMode\">\n              <div>Failure Mode:</div>\n              <select className=\"FailureSelect\" value={this.state.failureMode} onChange={this.handleFailureModeChange}>\n                <option value={FailureMode.None}>None</option>\n                <option value={FailureMode.Region}>Region</option>\n                <option value={FailureMode.DataCenter}>DataCenter</option>\n                <option value={FailureMode.AvailabilityZone}>AvailabilityZone</option>\n                <option value={FailureMode.Node}>Node</option>\n              </select>\n            </div>\n          </form>\n        </div>\n        {\n          nodeCount < this.state.replicationFactor && <div className=\"Underreplicated\">\n            The system is underreplicated: There are {nodeCount} nodes, but {this.state.replicationFactor} are needed.\n            </div>\n        }\n        {\n          this.state.failureMode !== FailureMode.None && <div className=\"FailureResults\">\n            <div>With {this.state.replicationFactor}x replication you can survive a max of {this.state.allowableDead} dead replica{this.state.allowableDead !== 1 && \"s\"}.</div>\n            <div>This scenario will survive losing at most:</div>\n            <div className=\"FailureTable\">\n              {!!this.state.failedRegions &&\n                <div className=\"FailureRow\">\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureHeader\">Regions</div>\n                  </div>\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureValue\">{this.state.failedRegions}</div>\n                  </div>\n                </div>\n              }\n              {!!(this.state.failedRegions || this.state.failedDCs) &&\n                <div className=\"FailureRow\">\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureHeader\">Data Centers</div>\n                  </div>\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureValue\">{this.state.failedDCs}</div>\n                  </div>\n                </div>\n              }\n              {!!(this.state.failedRegions || this.state.failedDCs || this.state.failedAZs) &&\n                <div className=\"FailureRow\">\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureHeader\">Availability Zones</div>\n                  </div>\n                  <div className=\"FailureColumn\">\n                    <div className=\"FailureValue\">{this.state.failedAZs}</div>\n                  </div>\n                </div>\n              }\n              <div className=\"FailureRow\">\n                <div className=\"FailureColumn\">\n                  <div className=\"FailureHeader\">Nodes</div>\n                </div>\n                <div className=\"FailureColumn\">\n                  <div className=\"FailureValue\">{this.state.failedNodes}</div>\n                </div>\n              </div>\n            </div>\n          </div>\n        }\n        <div className=\"App-container\">\n          {regions}\n        </div>\n      </div >\n    );\n  }\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <MainForm />\n      </header>\n    </div >\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}